lib:
- pads.ml
-- Replace sub_stats_with with Str module (probably)?
-- Improve file rep in general (mby using Core?)
    (*
    let l = Core.Std.In_channel.read_all path in
    *)
- padsParser.ml
-- Make sure check_eof works right
-- parse_pstring
--- Fix so newlines aren't handled specially, particularly constant size
    strings.
--- Decide whether to consume terminator (for regex especially)
-- parse_list
--- Don't use mutable state. Pass around a bool instead.
-- Add char and EOR parsing
(*
let parse_char (state : pads_parse_state) =
  if String.length state.current <= state.loc.character - 1
  then (' ', error_md [gen_err_msg "String was empty" state] (), state)
  else
    (String.get state.current (state.loc.character - 1), empty_md (), update_state state 1)

let parse_EOF (state : pads_parse_state) =
  if String.length state.current = state.loc.character - 1 && state.rest = []
  then ((), empty_md (), state)
  else ((), error_md [gen_err_msg "Not end of file" state] (), state)

let parse_EOR (state : pads_parse_state) =
  if String.length state.current = state.loc.character - 1 then ((), empty_md (), inc_line state)
  else ((), error_md [gen_err_msg "Not end of line" state] (), inc_line state)
*)

ppx_pads_lib.ml:
- parse_gen
-- Add better error info to Ppred (?)
-- Suppress warning 26?
     (* begin [@warning "-26"] *)

- pads_to_string
-- Fix Pstring (PFRE ..) if regex terminations consume
(* TODO: Add back to above if you make regex terminations consume
  Buffer.add_string buf [%e default_rep_gen (mk_ast loc @@ Pconst (PFRE re))]*)

- pads_manifest
-- Fix Pstring (PFRE ..) if regex terminations consume
    (* TODO: Add back to above if you make regex terminations consume
     * ^ [%e default_rep_gen (mk_ast loc @@ Pconst (PFRE re))] *)
-- Maybe there's some issue with fix_length strings?
    (* TODO: Fix fixed length str: <:expr< if String.length rep =
-$int:string_of_int n$ then [] else [ListLengthError] >> *)
-- Add regex check to Constant regexes
       (* TODO: Add regex check 
          let regex = Str.regexp r in
          let matches = Str.string_match regex rep 0 && Str.matched_string rep = rep in
          if matches then [] else [RegexMatchError r]] >>
       *)
-- Make sure list lengths are fine and that mds and reps are not mismatched
       (* TODO: Check list length is right. Check if there's a mismatch between rep and md length *)

Testing:
Useful for parser testing:
#mod_use "pads_types.ml";;
#mod_use "pads_parser.ml";;
#mod_use "pads_lexer.ml";;
let lexbuf = Lexing.from_string "d = directory { test is \"Woo\" ::  file } ";;
Pads_parser.prog Pads_lexer.read lexbuf;;
